Семафоры: +-, дождаться нуля

int semget(key_t key, int nsems, int flags) - получить дескриптор на массив семафоров
key - IPC_PRIVATE / ftok
flags - права доступа, IPC_CREATE



semctl(id, IPC_RMID) - удаление семафора




int semop(id, struct semop *ops, int n)
    struct semop *ops - массив операций 9над несколькими семафорами) 
    Выполняются транзакционно!!!



STRUCT SEMOP:

sem_num - номер семафора в наборе (индекс в массиве)
sem_op - +1|0|-1 -- |увелич./подождать нуля/уменьш.|
sem_flg - IPC_NOWAIT|SEM_UNDO  

IPC_NOWAIT: не ждать, если нельзя, то вернуть ошибку

SEM_UNDO:
    для каждого(!) семафора в каждом(!) процессе, который с этим семафором
    работает, заводится дополнительная перменная. В случае флага UNDO, то в
    эту переменную при выполнении операции
    добавляется(алгебраически!) значение sem_op.

    Если процесс вышел, и значение этой переменной ненулевое, то от семафора
    откатывается значение этой переменной (атомарно)!


----------------------------------------------------------------------------
Разделяемая память
----------------------------------------------------------------------------

int shmget(key_t key, int nsems, int flags) - получить дескриптор на shared память

void* shmat(id, NULL, 0); -- получить адрес на полученную память
В случае ошибки возвращает void * (-1) !!

key - IPC_PRIVATE / ftok
flags - права доступа, IPC_CREATE



shmctl(id, IPC_RMID) - удаление семафора
Работает, пока хоть кто-то подключен!

int shmdt(void* addr) - отключиться, выполняется автоматически при
выходе из программы


-----------------------------------------------------------------------------
Задача
-----------------------------------------------------------------------------
два процесса, не связанные отношением родитель-ребенок, запускаемые в
произвольном порядке, передают данные от одного к другому. Семафоры, shared memory






вещь не из стандарта: значение переменных семафора по умолчанию равны нулю.
