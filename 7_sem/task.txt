Сигналы очень похожи на прерывания.

Важен сам факт того, что был послан сигнал. Нет никакой гарантии, что обработчик будет вызван столько раз, сколько раз был отправлен сигнал.
(В системе выставяется "битик" 1 при отправлении сигнала).


Отправление сигнала:

1) ОС когда считает нужным, отправляет сигналы (в зависимости от сигнала).
2) Пользовтель модет отправить сигнал другому процессу при помощи вызова 
kill():


    int kill(pid_t pid, int signo);

Не бывает отрицательных номеров сигналов. Если signo = 0, то успех в случае существования этого процесса 
(единственный нормальный спооб узнать это!)

pid > 0: pid процесса текущего пользователя. (нельзя отправить сигнал процессу другого пользователя. (root может всё))
если pid < 0, то сигнал отправляется группе процесса. -1 -- отправить всем процессам.


signal -- не пользуемся.


Правильный системный вызов:
int sigaction(int signo, struct sigaction* act, NULL/ struct sigaction *old )
    номер сигнала, описание обработчика, структура, в которую запишется информация о прошлом разработчике


    Описание структуры:
    в простом случае:
    .sa_handler = handler (остальные поля занулены) 
    SIG_DFL или SIG_IGN

    
    
Системный вызов, разрешающий/запрещающий сигналы:
int sigprocmask(int how, const sigset_t *set, sigset_t *old)
        операция с маской

Функции для работы с sigset_t (всё просто):
sigemptyset
sigfillset
sigaddset
sigdelset
sigismember


    Поле how:
        что нам нужно сделать с этой маской. написано мутно, смысл простой:
        1) SIG_BLOCK // заблокировать, остальные оставить как есть
        2) SIG_UNBLOCK // разблокировать 1, остальные оставить как есть
        3) SIG_SETMASK // целиком заменить маску

        по умолчанию лежат нули, все сигналы разрешены (проверить)
    
sigpending - посмотреть сигналы, которые  пришли, но ещё не обработаны.


дождаться сигнала:
pause() - плохо, сигнал может прийти до pause()

Поэтому есть: sigsuspend(sigset_t* mask)
это атомарная версия следующей последовательности вызовов:
sigprocmask(
pause
sigprocmask(



Понадобится (а, может быть, и не понадобится):
int alarm(5) - отложенный сигнал. 
alarm(0) - снять системный вызов



Задачка на плюсик:


написать программу, которая должна породить дочерний процесс. Дочерний процесс читает файл, родительский его печатает. Коммуникация -- только сигнал (передавать вместе с сигналом байтик нельзя.)
printf, scanf, write, read, queues, shared_mem, pipe -- ничего нельзя.
